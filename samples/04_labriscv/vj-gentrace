#!/usr/bin/env python3

import argparse
import random
import re

parser = argparse.ArgumentParser(description='Generate a pseudorandom trace hex file for the verinject file driver')

parser.add_argument('mapfile', type=argparse.FileType('r'), help="The .map file generated by verinject")
parser.add_argument('--include', nargs='*', type=re.compile, help="If specified a signal must match at least against one of these regexes to be included in the random distribution")
parser.add_argument('--exclude', nargs='*', type=re.compile, help="If specified a signal must can't match any of these regexes to be included in the random distribution")
parser.add_argument('--seed', default=0, type=int, help="Seed for the random distribution")
parser.add_argument('--cycles', default=32768, type=int, help="Number of cycles")
parser.add_argument('--faults', default=None, type=int, help="Number of faults (defaults to 1/100 of cycle count)")
parser.add_argument('--memfile-size', default=1024, type=int, help="Total size of the memory file to generate in 64-bit words, used to pad it out with invalid values")

args = parser.parse_args()

if args.faults is None:
    args.faults = args.cycles // 100

def signal_allowed(sname: str) -> bool:
    allowed = True
    if args.include is not None:
        allowed = False
        for pat in args.include:
            if pat.search(sname) is not None:
                allowed = True
                break
    if args.exclude is not None:
        for pat in args.exclude:
            if pat.search(sname) is not None:
                return False
    return allowed

ranges = list()
allowed_nums = list()
with args.mapfile as f:
    for line in f:
        line = line.strip()
        if len(line) < 3:
            continue
        spl = line.split(' ')
        if len(spl) < 9:
            continue
        rg = {
            "start": int(spl[0]),
            "end": int(spl[1]),
            "path": spl[2],
            "lword": int(spl[4]),
            "rword": int(spl[5]),
            "lmem": int(spl[6]),
            "rmem": int(spl[7]),
            "kind": spl[8]
        }
        rg["wmin"] = min(rg["lword"], rg["rword"])
        rg["wmax"] = max(rg["lword"], rg["rword"])
        rg["wlen"] = rg["wmax"] - rg["wmin"] + 1
        rg["mmin"] = min(rg["lmem"], rg["rmem"])
        rg["mmax"] = max(rg["lmem"], rg["rmem"])
        rg["mlen"] = rg["mmax"] - rg["mmin"] + 1
        ranges.append(rg)
        if signal_allowed(rg['path']):
            rend = min(rg['end'], rg['start'] + 32*128)
            allowed_nums.extend(range(rg['start'], rend))

# Generation

gen = random.Random()
gen.seed(args.seed, 2)

inj_cycles = set()
for _ in range(0, args.faults):
    inj_cycles.add(gen.randrange(0, args.cycles))
inj_cycles = list(inj_cycles)
inj_cycles.sort()

lines_written = 0
for cycle in inj_cycles:
    bitid = gen.choice(allowed_nums)
    dataword = ((cycle&0xFFFF_FFFF) << 32) | (bitid&0xFFFF_FFFF)
    print('%016x' % (dataword,))
    lines_written += 1

F16 = 'f' * 16

for _ in range(0, max(0, args.memfile_size - lines_written)):
    print(F16)
